package consensus

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/luca-patrignani/mental-poker/domain/poker"
)

// Action represents a proposed poker action in the consensus protocol.
// Each action is uniquely identified, signed by its proposer, and timestamped.
type Action struct {
	Id        string            `json:"id"`         // Unique action identifier
	PlayerID  int               `json:"actor_id"`   // ID of the player proposing this action
	Payload   poker.PokerAction `json:"payload"`    // The actual poker action (bet, fold, etc.)
	Timestamp int64             `json:"ts"`         // Unix nanoseconds when action was signed
	Signature []byte            `json:"sig,omitempty"` // Ed25519 signature over action data
}

// ToString returns the JSON string representation of the Action.
// Useful for logging and debugging.
func (a *Action) ToString() string {
	b, _ := json.Marshal(a)
	return string(b)
}

// MakeAction creates a new Action with a unique ID derived from the actor ID,
// action payload, and cryptographic randomness.
//
// The ID is generated by combining:
//   - Actor ID
//   - Action payload hash
//   - 128 bits of cryptographic entropy
//
// The resulting ID is hex-encoded and truncated to 8 bytes for compactness.
//
// Note: The timestamp is not set until Sign() is called.
//
// Parameters:
//   - actorId: The player proposing this action
//   - payload: The poker action being proposed
//
// Returns the constructed action or an error if randomness cannot be generated.
func MakeAction(actorId int, payload poker.PokerAction) (Action, error) {
	randBytes := make([]byte, 16) // 128 bits entropy
	_, err := rand.Read(randBytes)
	if err != nil {
		return Action{}, err
	}
	raw := fmt.Sprintf("%d%x%x", actorId, payload, randBytes)
	b, _ := json.Marshal(raw)
	id := hex.EncodeToString(b[:8])

	return Action{
		Id:       id,
		PlayerID: actorId,
		Payload:  payload,
	}, nil
}

// VoteValue represents the outcome of validating a proposed action.
type VoteValue string

const (
	VoteAccept VoteValue = "ACCEPT" // Action is valid and should be committed
	VoteReject VoteValue = "REJECT" // Action is invalid and proposer should be banned
)

// Vote represents a node's decision on a proposed action.
// Each vote is cryptographically signed to prevent forgery.
type Vote struct {
	ActionId  string    `json:"proposal_id"`        // ID of the action being voted on
	VoterID   int       `json:"voter_id"`           // ID of the node casting this vote
	Value     VoteValue `json:"value"`              // ACCEPT or REJECT
	Reason    string    `json:"reason,omitempty"`   // Human-readable validation result
	Signature []byte    `json:"signature,omitempty"` // Ed25519 signature over vote data
}

// Certificate bundles a proposal with its quorum of votes.
// A certificate proves that consensus was reached on an action and serves as
// an immutable record in the ledger.
type Certificate struct {
	Proposal *Action  `json:"proposal"`          // The action that was voted on
	Votes    []Vote   `json:"votes"`             // Quorum votes (both accept and reject)
	Reason   string   `json:"reason,omitempty"`  // Aggregated reasons (used for bans)
}

// ProposeAction initiates the consensus protocol by broadcasting a poker action proposal.
//
// Protocol flow:
//   1. Verifies the proposer is the current player
//   2. Caches the proposal locally
//   3. Broadcasts to all peers with 30-second timeout
//   4. Processes the proposal through onReceiveProposal
//
// Returns an error if:
//   - The proposer is not the current player (out-of-turn)
//   - The player is not in the session
//   - The broadcast fails
//   - Proposal validation fails
//
// This method should only be called by the node whose turn it is to act.
func (node *ConsensusNode) ProposeAction(a *Action) error {
	idx := node.pokerSM.FindPlayerIndex(a.PlayerID)

	if idx < 0 {
		return fmt.Errorf("player not in session")
	}

	if idx != node.pokerSM.GetCurrentPlayer() {
		return fmt.Errorf("cannot propose out-of-turn")
	}

	// cache proposal
	node.proposal = a

	b, _ := json.Marshal(*node.proposal)
	if _, err := node.network.BroadcastwithTimeout(b, node.network.GetRank(), 30*time.Second); err != nil {
		return err
	}
	err := node.onReceiveProposal(node.proposal)
	if err != nil {
		return err
	}
	return nil
}

// WaitForProposal blocks until a proposal is received from the current player.
//
// This method should be called by all non-proposing nodes to receive and validate
// the next action proposal in the game.
//
// Protocol flow:
//   1. Determines which player should propose (current turn)
//   2. Waits for broadcast from that player (30-second timeout)
//   3. Unmarshals the received proposal
//   4. Processes through onReceiveProposal
//
// Returns an error if:
//   - The broadcast times out
//   - The proposal cannot be unmarshaled
//   - Proposal validation or voting fails
func (node *ConsensusNode) WaitForProposal() error {
	proposer := node.pokerSM.GetCurrentPlayer()

	data, err := node.network.BroadcastwithTimeout(nil, proposer, 30*time.Second)
	if err != nil {
		return err
	}
	var p Action
	if err := json.Unmarshal(data, &p); err != nil {
		return fmt.Errorf("failed to unmarshal action proposal: %v", err)
	}

	return node.onReceiveProposal(&p)
}

// onReceiveProposal validates a received action proposal by checking the proposer's signature,
// verifying player existence, and validating poker rules. It then broadcasts a vote
// (ACCEPT or REJECT) based on the validation result. Caches the proposal if missing.
func (node *ConsensusNode) onReceiveProposal(p *Action) error {
	//fmt.Printf("Node %d received proposal from player %d\nAction: %s", node.network.GetRank(), p.PlayerID,p.ToString())
	node.proposal = nil
	node.votes = map[int]Vote{}
	pub, find := node.playersPK[p.PlayerID]
	if !find {
		err := node.broadcastVoteForProposal(p, VoteReject, "unknown-player")
		if err != nil {
			return err
		}
		return nil
	}
	verified, err := p.VerifySignature(pub)
	if err != nil {
		return err
	}
	if !verified {
		err := node.broadcastVoteForProposal(p, VoteReject, "bad-signature")
		if err != nil {
			return err
		}
		return nil
	}

	invalid := node.pokerSM.Validate(p.Payload)
	if invalid != nil {
		err := node.broadcastVoteForProposal(p, VoteReject, invalid.Error())
		if err != nil {
			return err
		}
		return nil
	}

	err = node.broadcastVoteForProposal(p, VoteAccept, "valid")
	if err != nil {
		return err
	}
	return nil
}

// broadcastVoteForProposal creates and broadcasts a signed vote for the proposal to all peers.
// It caches the vote locally, collects all votes from peers via AllToAll, and processes them
// through onReceiveVotes. Supports voting either ACCEPT or REJECT with a reason string.
func (node *ConsensusNode) broadcastVoteForProposal(p *Action, v VoteValue, reason string) error {
	//fmt.Printf("Node %s voting %s for proposal from %s: %s\n", node.ID, v, p.Action.PlayerID, reason)

	vote := Vote{ActionId: p.Id,
		VoterID: node.network.GetRank(),
		Value:   v,
		Reason:  reason}

	err := vote.Sign(node.priv)
	if err != nil {
		return err
	}

	// cache proposal if missing
	if node.proposal == nil {
		node.proposal = p
	}

	node.votes[node.network.GetRank()] = vote

	//fmt.Printf("Node %s broadcasting vote %s for proposal %s\n", node.ID, v, pid)
	b, err := json.Marshal(vote)
	if err != nil {
		return err
	}
	votesBytes, err := node.network.AllToAllwithTimeout(b, 30*time.Second)
	if err != nil {
		return err
	}

	votes := make([]Vote, 0, len(votesBytes))
	for _, vb := range votesBytes {
		var v Vote
		if err := json.Unmarshal(vb, &v); err != nil {
			fmt.Printf("failed to unmarshal vote: %v\n", err)
			continue // skip malformed messages
		}
		votes = append(votes, v)
	}

	err = node.onReceiveVotes(votes)
	if err != nil {
		return err
	}
	return nil
}

// ensureSameProposal verifies that all votes in the slice reference the same action ID.
// Returns an error if the votes array is empty or if votes contain differing action IDs.
func ensureSameProposal(votes []Vote) error {
	if len(votes) == 0 {
		return fmt.Errorf("votes array is empty")
	}

	firstProposal := votes[0].ActionId
	for _, v := range votes[1:] {
		if v.ActionId != firstProposal {
			return fmt.Errorf("votes don't refer to the same proposal")
		}
	}
	return nil
}

// onReceiveVotes processes a collection of votes by validating signatures, checking voter
// eligibility, caching valid votes, and triggering checkAndCommit. Skips votes with invalid
// signatures or unknown voters, logging the issues.
func (node *ConsensusNode) onReceiveVotes(votes []Vote) error {
	err := ensureSameProposal(votes)
	if err != nil {
		fmt.Printf("Node %d received invalid votes: %v\n", node.network.GetRank(), err)
		return err
	}

	//fmt.Printf("Node %s processing %d votes\n", node.ID, len(votes))

	// cache valid votes
	for _, v := range votes {
		pub, present := node.playersPK[v.VoterID]
		if !present {
			fmt.Printf("unknown voter: %d\n", v.VoterID)
			continue
		}

		ok, err := v.VerifySignature(pub)
		if err != nil {
			return err
		}
		if !ok {
			fmt.Printf("bad signature from %d\n", v.VoterID)
			continue
		}

		if idx := node.pokerSM.FindPlayerIndex(v.VoterID); idx == -1 {
			fmt.Printf("Vote doesn't match any known player\n")
			continue
		}

		node.votes[v.VoterID] = v
	}

	// now check quorum
	err = node.checkAndCommit()
	if err != nil {
		return err
	}
	return nil

}

// checkAndCommit evaluates whether quorum has been reached for either accepting or rejecting
// the current proposal. If accepts >= quorum, commits the action. If rejects >= quorum,
// bans the proposer. Returns an error if neither quorum is reached or if commit fails.
func (node *ConsensusNode) checkAndCommit() error {

	if node.proposal == nil {
		return fmt.Errorf("missing proposal to commit")
	}

	accepts := len(collectVotes(node.votes, VoteAccept))
	rejectVotes := collectVotes(node.votes, VoteReject)
	rejects := len(rejectVotes)
	reason := getBanReason(rejectVotes)
	cert := Certificate{
		Proposal: node.proposal,
		Votes:    collectVotes(node.votes, "both"),
		Reason:   reason,
	}
	if accepts >= node.quorum {
		//fmt.Printf("Node %s committing proposal %s\n", node.ID, proposalID)

		err := node.applyCommit(cert)
		if err != nil {
			return err
		}
		return nil
	} else if rejects >= node.quorum {
		//fmt.Printf("Node %s banning player due to s\n", node.ID)
		payload, err := node.pokerSM.NotifyBan(cert.Proposal.PlayerID)

		if err != nil {
			return err
		}
		cert.Proposal.Payload = payload
		err = node.applyCommit(cert, cert.Proposal)
		if err != nil {
			return err
		}
		if node.network.GetRank() == cert.Proposal.PlayerID {
			err := node.network.Close()
			if err != nil {
				return err
			}
			fmt.Printf("You have been banned for %s Shutting down Now\n", reason)
			return nil
		}
		delete(node.playersPK, cert.Proposal.PlayerID)
		node.quorum = computeQuorum(node.network.GetPeerCount())
		return nil
	}

	return fmt.Errorf("not enough elegible votes to reach quorum yet, state not changed. (%d accepts, %d rejects (%s), need %d)", accepts, rejects, reason, node.quorum)
}

// collectVotes filters votes from the vote map by value. If filter is "both", returns all votes;
// otherwise returns only votes matching the specified VoteValue (ACCEPT or REJECT).
func collectVotes(m map[int]Vote, filter VoteValue) []Vote {
	out := []Vote{}
	for _, v := range m {
		if v.Value == filter || filter == "both" {
			out = append(out, v)
		}
	}
	return out
}

// getBanReason extracts unique rejection reasons from reject votes and concatenates them
// into a semicolon-separated string for logging or record keeping.
func getBanReason(rejectVotes []Vote) string {
	reason := ""
	for _, vv := range rejectVotes {
		if reason != vv.Reason+"; " {
			reason += vv.Reason + "; "
		}
	}
	return reason
}

// applyCommit applies a validated certificate by executing the state machine action,
// appending to the ledger, and removing the banned proposer from the peer map (if applicable).
// The optional ban parameter is used when the proposal represents a player banning.
func (node *ConsensusNode) applyCommit(cert Certificate, ban ...*Action) error {
	//fmt.Printf("Node %d applying commit certificate for proposal \n%s\n", node.network.GetRank(), cert.Proposal.ToString())
	if cert.Proposal == nil {
		return errors.New("bad certificate format")
	}
	err := node.pokerSM.Apply(cert.Proposal.Payload)
	if err != nil {
		return err
	}

	ses := node.pokerSM.GetSession()

	if len(ban) > 0 {
		data := map[string]string{"rejectedAction": ban[0].ToString()}

		err = node.ledger.Append(*ses, cert.Proposal.Payload, cert.Votes, cert.Proposal.PlayerID, node.quorum, data)
		if err != nil {
			return err
		}
	} else {
		err := node.ledger.Append(*ses, cert.Proposal.Payload, cert.Votes, cert.Proposal.PlayerID, node.quorum)
		if err != nil {
			return err
		}
	}
	return nil
}
