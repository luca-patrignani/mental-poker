package consensus

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/luca-patrignani/mental-poker/domain/poker"
)

// Action represents a proposed poker action in the consensus protocol.
// Each action is uniquely identified, signed by its proposer, and timestamped.
type Action struct {
	Id        string            `json:"id"`            // Unique action identifier
	PlayerID  int               `json:"actor_id"`      // ID of the player proposing this action
	Payload   poker.PokerAction `json:"payload"`       // The actual poker action (bet, fold, etc.)
	Timestamp int64             `json:"ts"`            // Unix nanoseconds when action was signed
	Signature []byte            `json:"sig,omitempty"` // Ed25519 signature over action data
}

// ToString returns the JSON string representation of the Action.
// Useful for logging and debugging.
func (a *Action) ToString() string {
	b, _ := json.Marshal(a)
	return string(b)
}

// MakeAction creates a new Action with a unique ID derived from the actor ID,
// action payload, and cryptographic randomness.
//
// The ID is generated by combining:
//   - Actor ID
//   - Action payload hash
//   - 128 bits of cryptographic entropy
//
// The resulting ID is hex-encoded and truncated to 8 bytes for compactness.
//
// Note: The timestamp is not set until Sign() is called.
//
// Parameters:
//   - actorId: The player proposing this action
//   - payload: The poker action being proposed
//
// Returns the constructed action or an error if randomness cannot be generated.
func MakeAction(actorId int, payload poker.PokerAction) (Action, error) {
	randBytes := make([]byte, 16) // 128 bits entropy
	_, err := rand.Read(randBytes)
	if err != nil {
		return Action{}, err
	}
	raw := fmt.Sprintf("%d%x%x", actorId, payload, randBytes)
	b, _ := json.Marshal(raw)
	id := hex.EncodeToString(b[:8])

	return Action{
		Id:       id,
		PlayerID: actorId,
		Payload:  payload,
	}, nil
}

// VoteValue represents the outcome of validating a proposed action.
type VoteValue string

const (
	VoteAccept VoteValue = "ACCEPT" // Action is valid and should be committed
	VoteReject VoteValue = "REJECT" // Action is invalid and proposer should be banned
)

// Vote represents a node's decision on a proposed action.
// Each vote is cryptographically signed to prevent forgery.
type Vote struct {
	ActionId  string    `json:"proposal_id"`         // ID of the action being voted on
	VoterID   int       `json:"voter_id"`            // ID of the node casting this vote
	Value     VoteValue `json:"value"`               // ACCEPT or REJECT
	Reason    string    `json:"reason,omitempty"`    // Human-readable validation result
	Signature []byte    `json:"signature,omitempty"` // Ed25519 signature over vote data
}

// Certificate bundles a proposal with its quorum of votes.
// A certificate proves that consensus was reached on an action and serves as
// an immutable record in the ledger.
type Certificate struct {
	Proposal *Action `json:"proposal"`         // The action that was voted on
	Votes    []Vote  `json:"votes"`            // Quorum votes (both accept and reject)
	Reason   string  `json:"reason,omitempty"` // Aggregated reasons (used for bans)
}

// ProposeAction initiates the consensus protocol by broadcasting a poker action proposal.
//
// Protocol Steps:
//   1. Validates that the proposer is the current player
//   2. Caches the proposal locally
//   3. Broadcasts to all peers with 30-second timeout
//   4. Validates and votes on own proposal
//   5. Collects votes from peers
//   6. Commits if quorum is reached
//
// This method should ONLY be called when it's your turn to act. Calling it
// out-of-turn will result in an error and potential ban.
//
// Parameters:
//   - a: Signed action to propose (must be signed before calling)
//
// Returns an error if:
//   - Proposer is not the current player
//   - Player is not in the session
//   - Broadcast fails or times out
//   - Validation or voting fails
func (node *ConsensusNode) ProposeAction(a *Action) error {
	idx := node.pokerSM.FindPlayerIndex(a.PlayerID)

	if idx < 0 {
		return fmt.Errorf("player not in session")
	}

	if idx != node.pokerSM.GetCurrentPlayer() {
		return fmt.Errorf("cannot propose out-of-turn")
	}

	// cache proposal
	node.proposal = a

	b, _ := json.Marshal(*node.proposal)
	if _, err := node.network.BroadcastwithTimeout(b, node.network.GetRank(), 30*time.Second); err != nil {
		return err
	}
	err := node.onReceiveProposal(node.proposal)
	if err != nil {
		return err
	}
	return nil
}

// WaitForProposal blocks until a proposal is received from the current player.
// This should be called by all non-proposing nodes during another player's turn.
//
// Protocol Steps:
//   1. Determines which player should propose next
//   2. Waits for broadcast from that player (30-second timeout)
//   3. Unmarshals the received proposal
//   4. Validates and votes on the proposal
//   5. Collects votes from all peers
//   6. Commits if quorum is reached
//
// Parameters: None (uses internal state to determine proposer)
//
// Returns an error if:
//   - Broadcast times out (proposer disconnected or delayed)
//   - Proposal is malformed (invalid JSON)
//   - Validation or voting fails
func (node *ConsensusNode) WaitForProposal() error {
	proposer := node.pokerSM.GetCurrentPlayer()

	data, err := node.network.BroadcastwithTimeout(nil, proposer, 30*time.Second)
	if err != nil {
		return err
	}
	var p Action
	if err := json.Unmarshal(data, &p); err != nil {
		return fmt.Errorf("failed to unmarshal action proposal: %v", err)
	}

	return node.onReceiveProposal(&p)
}

// onReceiveProposal validates a received proposal and broadcasts a vote.
//
// Validation checks (in order):
//   1. Proposer's public key is known
//   2. Cryptographic signature is valid
//   3. Player exists in current session
//   4. Action complies with poker rules
//
// If any check fails, broadcasts REJECT vote with reason. Otherwise broadcasts ACCEPT.
//
// Parameters:
//   - p: The proposal to validate
//
// Returns an error if vote broadcasting fails.
func (node *ConsensusNode) onReceiveProposal(p *Action) error {
	//fmt.Printf("Node %d received proposal from player %d\nAction: %s", node.network.GetRank(), p.PlayerID,p.ToString())
	node.proposal = nil
	node.votes = map[int]Vote{}
	pub, find := node.playersPK[p.PlayerID]
	if !find {
		err := node.broadcastVoteForProposal(p, VoteReject, "unknown-player")
		if err != nil {
			return err
		}
		return nil
	}
	verified, err := p.VerifySignature(pub)
	if err != nil {
		return err
	}
	if !verified {
		err := node.broadcastVoteForProposal(p, VoteReject, "bad-signature")
		if err != nil {
			return err
		}
		return nil
	}

	invalid := node.pokerSM.Validate(p.Payload)
	if invalid != nil {
		err := node.broadcastVoteForProposal(p, VoteReject, invalid.Error())
		if err != nil {
			return err
		}
		return nil
	}

	err = node.broadcastVoteForProposal(p, VoteAccept, "valid")
	if err != nil {
		return err
	}
	return nil
}

// broadcastVoteForProposal creates, signs, and broadcasts a vote for the proposal.
// Then collects all votes from peers via AllToAll communication.
//
// This method handles both ACCEPT and REJECT votes, caching them locally
// and then checking if quorum has been reached.
//
// Parameters:
//   - p: The proposal being voted on
//   - v: Vote value (ACCEPT or REJECT)
//   - reason: Human-readable explanation (e.g., "valid", "insufficient-funds")
//
// Returns an error if signing, broadcasting, or vote collection fails.
func (node *ConsensusNode) broadcastVoteForProposal(p *Action, v VoteValue, reason string) error {
	//fmt.Printf("Node %s voting %s for proposal from %s: %s\n", node.ID, v, p.Action.PlayerID, reason)

	vote := Vote{ActionId: p.Id,
		VoterID: node.network.GetRank(),
		Value:   v,
		Reason:  reason}

	err := vote.Sign(node.priv)
	if err != nil {
		return err
	}

	// cache proposal if missing
	if node.proposal == nil {
		node.proposal = p
	}

	node.votes[node.network.GetRank()] = vote

	//fmt.Printf("Node %s broadcasting vote %s for proposal %s\n", node.ID, v, pid)
	b, err := json.Marshal(vote)
	if err != nil {
		return err
	}
	votesBytes, err := node.network.AllToAllwithTimeout(b, 30*time.Second)
	if err != nil {
		return err
	}

	votes := make([]Vote, 0, len(votesBytes))
	for _, vb := range votesBytes {
		var v Vote
		if err := json.Unmarshal(vb, &v); err != nil {
			fmt.Printf("failed to unmarshal vote: %v\n", err)
			continue // skip malformed messages
		}
		votes = append(votes, v)
	}

	err = node.onReceiveVotes(votes)
	if err != nil {
		return err
	}
	return nil
}

// ensureSameProposal verifies that all votes reference the same action ID.
// This prevents mixing votes from different proposals.
//
// Parameters:
//   - votes: Slice of votes to verify
//
// Returns an error if votes are empty or reference different proposals.
func ensureSameProposal(votes []Vote) error {
	if len(votes) == 0 {
		return fmt.Errorf("votes array is empty")
	}

	firstProposal := votes[0].ActionId
	for _, v := range votes[1:] {
		if v.ActionId != firstProposal {
			return fmt.Errorf("votes don't refer to the same proposal")
		}
	}
	return nil
}

// onReceiveVotes processes a collection of votes by validating signatures,
// checking voter eligibility, caching valid votes, and triggering consensus check.
//
// Invalid votes (bad signature, unknown voter) are logged but not cached.
// This prevents Byzantine nodes from disrupting consensus with fake votes.
//
// Parameters:
//   - votes: All votes received from peers
//
// Returns an error if consensus checking fails.
func (node *ConsensusNode) onReceiveVotes(votes []Vote) error {
	err := ensureSameProposal(votes)
	if err != nil {
		fmt.Printf("Node %d received invalid votes: %v\n", node.network.GetRank(), err)
		return err
	}

	//fmt.Printf("Node %s processing %d votes\n", node.ID, len(votes))

	// cache valid votes
	for _, v := range votes {
		pub, present := node.playersPK[v.VoterID]
		if !present {
			fmt.Printf("unknown voter: %d\n", v.VoterID)
			continue
		}

		ok, err := v.VerifySignature(pub)
		if err != nil {
			return err
		}
		if !ok {
			fmt.Printf("bad signature from %d\n", v.VoterID)
			continue
		}

		if idx := node.pokerSM.FindPlayerIndex(v.VoterID); idx == -1 {
			fmt.Printf("Vote doesn't match any known player\n")
			continue
		}

		node.votes[v.VoterID] = v
	}

	// now check quorum
	err = node.checkAndCommit()
	if err != nil {
		return err
	}
	return nil

}

// checkAndCommit determines if quorum has been reached and commits accordingly.
//
// Three outcomes:
//   1. ACCEPT quorum reached → Commit the action, apply to state
//   2. REJECT quorum reached → Ban the proposer, remove from game
//   3. No quorum → Return error (need more votes)
//
// When banning a player:
//   - Creates a ban action
//   - Commits it to the ledger
//   - Removes player from consensus group
//   - Closes connection if this node is being banned
//
// Returns an error if:
//   - No proposal is cached (protocol violation)
//   - Quorum not reached yet
//   - Commit operation fails
func (node *ConsensusNode) checkAndCommit() error {

	if node.proposal == nil {
		return fmt.Errorf("missing proposal to commit")
	}

	accepts := len(collectVotes(node.votes, VoteAccept))
	rejectVotes := collectVotes(node.votes, VoteReject)
	rejects := len(rejectVotes)
	reason := getBanReason(rejectVotes)
	cert := Certificate{
		Proposal: node.proposal,
		Votes:    collectVotes(node.votes, "both"),
		Reason:   reason,
	}
	if accepts >= node.quorum {
		//fmt.Printf("Node %s committing proposal %s\n", node.ID, proposalID)

		err := node.applyCommit(cert)
		if err != nil {
			return err
		}
		return nil
	} else if rejects >= node.quorum {
		//fmt.Printf("Node %s banning player due to s\n", node.ID)
		payload, err := node.pokerSM.NotifyBan(cert.Proposal.PlayerID)

		if err != nil {
			return err
		}
		cert.Proposal.Payload = payload
		err = node.applyCommit(cert, cert.Proposal)
		if err != nil {
			return err
		}
		if node.network.GetRank() == cert.Proposal.PlayerID {
			err := node.network.Close()
			if err != nil {
				return err
			}
			fmt.Printf("You have been banned for %s Shutting down Now\n", reason)
			return nil
		}
		delete(node.playersPK, cert.Proposal.PlayerID)
		node.quorum = computeQuorum(node.network.GetPeerCount())
		return nil
	}

	return fmt.Errorf("not enough elegible votes to reach quorum yet, state not changed. (%d accepts, %d rejects (%s), need %d)", accepts, rejects, reason, node.quorum)
}

// collectVotes filters votes by value (ACCEPT, REJECT, or "both").
// Used to count votes for quorum determination.
//
// Parameters:
//   - m: Map of voter IDs to votes
//   - filter: Vote value to filter by, or "both" for all votes
//
// Returns a slice of matching votes.
func collectVotes(m map[int]Vote, filter VoteValue) []Vote {
	out := []Vote{}
	for _, v := range m {
		if v.Value == filter || filter == "both" {
			out = append(out, v)
		}
	}
	return out
}

// getBanReason aggregates unique rejection reasons from REJECT votes.
// Returns a semicolon-separated string for logging and ledger records.
//
// Parameters:
//   - rejectVotes: All votes with value REJECT
//
// Returns concatenated unique reasons (e.g., "invalid-bet; insufficient-funds;").
func getBanReason(rejectVotes []Vote) string {
	reason := ""
	for _, vv := range rejectVotes {
		if reason != vv.Reason+"; " {
			reason += vv.Reason + "; "
		}
	}
	return reason
}

// applyCommit applies a validated certificate by:
//   1. Executing the action through the state machine
//   2. Appending the decision to the ledger
//   3. Removing banned players from consensus (if applicable)
//
// Parameters:
//   - cert: Certificate containing proposal and quorum votes
//   - ban: Optional rejected action (included in ledger metadata)
//
// Returns an error if state application or ledger append fails.
func (node *ConsensusNode) applyCommit(cert Certificate, ban ...*Action) error {
	//fmt.Printf("Node %d applying commit certificate for proposal \n%s\n", node.network.GetRank(), cert.Proposal.ToString())
	if cert.Proposal == nil {
		return errors.New("bad certificate format")
	}
	err := node.pokerSM.Apply(cert.Proposal.Payload)
	if err != nil {
		return err
	}

	ses := node.pokerSM.GetSession()

	if len(ban) > 0 {
		data := map[string]string{"rejectedAction": ban[0].ToString()}

		err = node.ledger.Append(*ses, cert.Proposal.Payload, cert.Votes, cert.Proposal.PlayerID, node.quorum, data)
		if err != nil {
			return err
		}
	} else {
		err := node.ledger.Append(*ses, cert.Proposal.Payload, cert.Votes, cert.Proposal.PlayerID, node.quorum)
		if err != nil {
			return err
		}
	}
	return nil
}
