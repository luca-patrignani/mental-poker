\documentclass{article}

\usepackage{style}

% version

\newcommand{\versionmajor}{0}

\newcommand{\versionminor}{1}

\newcommand{\versionpatch}{0}

\newcommand{\version}{\versionmajor.\versionminor.\versionpatch}

\title{\LARGE
Mental Poker: A Decentralized Implementation \\
\large Version \version
}

% Consider watching:
% https://www.youtube.com/watch?v=ihxSUsJB_14
% https://www.youtube.com/watch?v=XTFWaV55uDo

\author{
Galeri Marco \\ \emailaddr{marco.galeri@studio.unibo.it}
\and
Patrignani Luca \\ \emailaddr{luca.patrignani3@studio.unibo.it}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This project implements a decentralized poker game (Texas Hold'em) without requiring a trusted third party. The implementation guarantees fairness even when $k-1$ out of $k$ players form a malicious coalition attempting to rig the game. The system consists of three main components: a cryptographic deck library implementing the Wei \& Wang mental poker protocol, a poker game engine managing game logic and state, and a blockchain-based distributed ledger ensuring non-repudiation of player actions. The architecture follows a peer-to-peer design with broadcast-based communication primitives, enabling fully distributed gameplay over local area networks. The delivered artifacts include two Go libraries (deck and poker) and a command-line interface for playing poker games. Automated testing validates the cryptographic security properties and game mechanics, achieving comprehensive test coverage of core functionalities.
\end{abstract}

\section{Goal/s of the project}

The project's goal is to implement a decentralized poker game without a trusted third party. In particular, our implementation guarantees that given $k$ players, an adversary cannot rig the game even when controlling $k-1$ players.

\subsection{Detailed Description}

Mental poker is a classic problem in cryptographic protocol design, first formulated by Shamir, Rivest, and Adleman in 1979. The challenge is to enable multiple distrustful parties to play a fair card game remotely without requiring a trusted dealer or central authority. Traditional online poker platforms rely on a centralized server that acts as the trusted dealer, shuffling cards and dealing them to players. However, this approach requires players to trust the server operator.

Our implementation addresses this trust problem by distributing the dealer's responsibilities among all players using cryptographic protocols. Each player participates in deck preparation, shuffling, and card dealing operations. The system ensures that:

\begin{itemize}
\item No single player or coalition of $k-1$ players can determine the order of cards in the deck
\item Players cannot see cards dealt to others until those cards are revealed
\item All players can verify that cards shown by others are legitimate and were not fabricated
\item Player actions (bets, raises, folds) are immutably recorded and cannot be repudiated
\end{itemize}

The implementation targets local area network gameplay, where players connect directly to each other in a peer-to-peer fashion. This use case is particularly relevant for casual games among friends or small tournaments where players want to ensure fairness without relying on external services.

\subsection{Usage scenarios}

\subsubsection{Scenario 1: Casual Game Among Friends}

Alice, Bob, and Charlie want to play poker together remotely. They each run the mental poker application on their computers. One player (say Alice) initializes the network and shares connection details with the others. Once all players are connected, they can start a game session. The system handles all cryptographic operations transparently - players simply interact through the command-line interface to make their betting decisions (call, raise, fold). The blockchain ledger maintains a complete history of the game for post-game verification if needed.

\subsubsection{Scenario 2: Tournament Play}

A group of players organizes a small poker tournament. Multiple game sessions run concurrently with different player groups. The decentralized architecture ensures that no central authority can manipulate outcomes. Players can verify the integrity of their specific games by examining the blockchain ledger. The absence of a central server eliminates single points of failure and potential manipulation.

\subsubsection{Scenario 3: Educational Demonstration}

Computer science students learning about cryptographic protocols use the mental poker implementation as a practical example. They can examine the source code to understand how the Wei \& Wang protocol works, run games while monitoring network traffic to see the cryptographic operations, and modify the code to experiment with different protocol parameters or attack scenarios (demonstrating security guarantees when attempting to cheat).

\subsection{Definition of done}

The delivered artifacts are:

\begin{itemize}
\item A golang library (\texttt{domain/deck}) which implements a decentralized deck and operations such as shuffling, dealing face-down cards, and revealing cards. The implementation follows the paper by Wei and Wang~\cite{Wei-Wang-Protocol}.

\item A golang library (\texttt{domain/poker}) which implements the actual game of poker, including game state management, betting rounds, hand evaluation, and winner determination.

\item A golang library (\texttt{ledger}) implementing a blockchain-based distributed ledger for recording player actions with consensus voting mechanisms.

\item A golang library (\texttt{network}) providing peer-to-peer communication primitives (broadcast and all-to-all operations) over TCP.

\item A command-line interface (\texttt{cmd/}) for playing poker games with a text-based user interface.
\end{itemize}

The functionalities are tested automatically with comprehensive unit tests for each component. Integration tests validate the end-to-end workflow of complete poker games with multiple players.

\section{Background and link to the theory}

\subsection{Architectural Styles}

The project employs a \textbf{peer-to-peer (P2P) architectural style}, where all nodes (players) have equal responsibilities and capabilities. Unlike client-server architectures, there is no central coordinator or privileged node. Each player runs identical software and participates equally in all cryptographic protocols.

This choice aligns with the project requirements for decentralization and fault tolerance. A centralized architecture would introduce a trusted third party, contradicting the fundamental goal. The P2P style ensures that:

\begin{itemize}
\item No player has privileged access or control
\item Security properties hold even with $k-1$ malicious players
\end{itemize}

\subsection{Interaction Patterns}

The implementation uses \textbf{broadcast-based communication patterns} inspired by high-performance computing frameworks, specifically the Message Passing Interface (MPI)~\cite{mpi41}. Two primary communication primitives are employed:

\begin{enumerate}
\item \textbf{Broadcast (one-to-all)}: A single player sends data to all other players. This is analogous to \texttt{MPI\_BCAST} in MPI. Used when one player needs to share information with the group (e.g., broadcasting encrypted cards during shuffling).

\item \textbf{All-to-all (all-to-all)}: Every player sends data to every other player simultaneously. Analogous to \texttt{MPI\_ALLTOALL}. Used when all players must contribute information (e.g., generating random elements for card initialization).
\end{enumerate}

Both primitives implement \textbf{barrier synchronization}, blocking until all players complete the operation. This ensures consistent state across all nodes and simplifies reasoning about protocol correctness.

The communication model follows the \textbf{Single Program, Multiple Data (SPMD)} paradigm~\cite{spmd}, commonly used in parallel programming. All nodes execute the same program (protocol logic), but each operates on different data (its own secret key, hand, etc.) and may take different execution paths based on its player ID.

\subsection{Cryptographic Frameworks}

The project uses \textbf{Kyber}, a Go cryptography library providing elliptic curve operations. Specifically, the Ed25519 curve suite is used for:

\begin{itemize}
\item \textbf{Scalar operations}: Secret key generation and manipulation
\item \textbf{Point operations}: Card representation as curve points, encryption through scalar multiplication
\item \textbf{Homomorphic properties}: Enabling multiple players to collectively encrypt the deck without revealing individual secret keys
\end{itemize}

The Wei \& Wang protocol leverages the discrete logarithm problem on elliptic curves to provide computational security guarantees.

\subsection{Distributed Ledger Technology}

A \textbf{replicated log} similar to a \textit{blockchain} data structure keeps track of the state of the game in an \textbf{event sourcing} fashion, recording all game actions with consensus verification. Each block contains:

\begin{itemize}
\item Player action (type, amount)
\item Consensus votes from all players
\item Cryptographic hash linking to the previous block
\end{itemize}

This provides \textbf{non-repudiation}, so players cannot deny actions they performed, as all actions are cryptographically signed and verified by the group. The replicated log also enables post-game auditing and dispute resolution.

\subsubsection{RESTful Architecture Characteristics}

The system architecture exhibits some \textbf{RESTful attributes} through its state-based design, making a transition to HTTP-based APIs trivial. The replicated log structure naturally aligns with REST principles:

\begin{itemize}
\item \textbf{Stateless transitions}: Each action transforms one complete game state into another, making the system naturally stateless between actions. The server (or in our case, the distributed consensus) does not need to maintain session information.

\item \textbf{Uniform interface}: All state transitions follow the same consensus-vote-append pattern, providing a consistent interaction model regardless of the specific action being performed.

\item \textbf{Self-descriptive messages}: Each block in the replicated log is self-contained, including all information needed to understand the action, validate consensus, and verify cryptographic integrity.

\item \textbf{Hypermedia as the engine of application state (HATEOAS)}: The blockchain structure naturally implements this principle - each block links to the previous block via hash, creating a navigable history of state transitions.
\end{itemize}

\subsubsection{Possible Transition to HTTP-based Implementation and Deployement scenario}

The current peer-to-peer implementation could be adapted to a RESTful HTTP API without fundamental architectural changes:

\begin{enumerate}
\item \textbf{Replace broadcast primitives with HTTP}: The current \texttt{Broadcast()} and \texttt{AllToAll()} operations can be replaced with HTTP POST requests to all peers, maintaining the same semantic behavior.

\item \textbf{Expose game state as REST resources}: The \texttt{Session} struct maps directly to a JSON resource representation that can be served via HTTP endpoints.

\item \textbf{Consensus via webhooks}: Instead of synchronous consensus voting, players could register webhook endpoints to receive and vote on proposed actions asynchronously.

\item \textbf{Maintain cryptographic guarantees}: The cryptographic deck operations and blockchain verification remain unchanged - only the transport layer shifts from raw TCP to HTTP.
\end{enumerate}

This RESTful characteristic enables several deployment scenarios:

\begin{itemize}
\item \textbf{Hybrid architecture}: A web-based user interface communicating with the P2P backend via REST API
\item \textbf{Cloud deployment}: Fully HTTP-based implementation for scenarios where P2P connectivity is challenging (NAT traversal, firewalls)
\item \textbf{Mobile clients}: Native iOS/Android apps consuming the REST API
\item \textbf{Third-party integrations}: External services can observe or participate in games via standard HTTP interfaces
\end{itemize}

The event sourcing pattern combined with RESTful principles makes the system highly flexible and adaptable to different deployment contexts while preserving the core security and fairness guarantees.


\section{Requirements Analysis}
\label{sec:requirements}

\subsection{Functional requirements}

The player is able to play a game of Texas Hold'em poker following standard rules:

\begin{enumerate}
\item \textbf{Initial Deal}: The player receives two private cards (hole cards), which are not visible to any other players.

\item \textbf{Betting Actions}: When it is the player's turn, they can perform one of the following actions:
\begin{itemize}
\item \textbf{Call}: Match the current highest bet
\item \textbf{Raise}: Increase the current bet amount  
\item \textbf{Fold}: Exit the current hand, forfeiting any bets made
\item \textbf{Check}: Pass without betting (only when no bet has been made)
\item \textbf{All-in}: Bet all remaining chips
\end{itemize}

\item \textbf{Flop Phase}: When the initial betting round completes (big blind checks or all players call the raise), three community cards are dealt face-up on the board.

\item \textbf{Turn Phase}: After the flop betting round completes, one additional community card is dealt face-up.

\item \textbf{River Phase}: After the turn betting round completes, a final community card is dealt face-up.

\item \textbf{Showdown}: After the river betting round completes, all remaining players reveal their hole cards. The winner is determined by the best five-card poker hand using any combination of hole cards and community cards.

\item \textbf{Early Termination}: If only one player remains in the game (all others have folded), that player wins immediately without proceeding to showdown.

\item \textbf{Pot Distribution}: The winner(s) receive the pot. In cases of all-in scenarios, side pots are calculated and distributed appropriately to eligible players.
\end{enumerate}

\subsection{Non functional requirements}

\subsubsection{Deck's requirements}

Each of the following requirements must be satisfied even when a coalition of $k-1$ players (out of $k$ total) attempts to manipulate the game without the remaining player detecting the manipulation:

\begin{itemize}
\item \textbf{Shuffle Fairness}: When shuffling the deck, no player or coalition can control the final order of the cards. The order must be uniformly random from the perspective of any player.

\item \textbf{Shuffle Privacy}: After the deck is shuffled, no player knows the order of the cards (beyond their own influence on the randomization).

\item \textbf{Deck Completeness}: All 52 cards are present in the deck exactly once. No cards are missing, duplicated, or fabricated.

\item \textbf{Card Privacy}: When a card is dealt to a player face-down, no other player can determine which card it is. The card remains private until the owning player chooses to reveal it.

\item \textbf{Card Verifiability}: When a player reveals a card, other players can verify that the player is not lying about which card they hold. The revealed card must be provably one of the cards from the shuffled deck.

\item \textbf{Cryptographic Security}: The protocols provide computational security based on the discrete logarithm problem. Breaking the security would require solving computationally infeasible problems.
\end{itemize}

\subsubsection{Poker game's requirements}

\begin{itemize}
\item \textbf{Fair Deck Usage}: The game uses a deck which meets all the cryptographic security requirements described above.

\item \textbf{Action Non-repudiation}: When a player makes a move (call, raise, fold, check), they cannot later deny or repudiate that choice. All actions are recorded immutably in the blockchain ledger with consensus verification.

\item \textbf{State Consistency}: All players maintain a consistent view of the game state (current round, pot size, player positions, community cards). Consensus mechanisms ensure agreement on state transitions.

\item \textbf{Byzantine Fault Tolerance}: The game continues correctly even when some players behave maliciously (within the $\frac{2}{3} k$ coalition limit)

\item \textbf{Liveness}: The game makes progress as long as a sufficient number of honest players remain active. Malicious players cannot indefinitely stall the game.

\item \textbf{Auditability}: Complete game history is recorded in the blockchain, enabling post-game verification and dispute resolution.
\end{itemize}

\subsection{Top-down analysis}

\subsubsection{Deck implementation}

Due to the decentralized nature of the project, every communication is modeled as a \textit{broadcast}, where a player communicates with all other players simultaneously by sending identical information to everyone. This constraint arises from the requirement that no player can have private communication channels with subsets of players, which could enable collusion.

The \textbf{broadcast communication model} has several implications for the architecture:

\begin{itemize}
\item \textbf{Symmetry}: All players observe the same messages in the same order, ensuring consistent state.

\item \textbf{Transparency}: All protocol steps are visible to all participants, enabling verification but also requiring careful cryptographic design to protect privacy.

\item \textbf{Simplicity}: The communication topology is fully connected, simplifying protocol design compared to partial network graphs.

\item \textbf{Scalability limits}: Broadcast overhead grows with player count, making the approach most suitable for small to medium-sized games (up to 10-20 players).
\end{itemize}

\subsubsection{Interaction pattern selection}

The \textbf{MPI-inspired broadcast primitives} were chosen because:

\begin{itemize}
\item \textbf{Protocol compatibility}: The Wei \& Wang paper describes operations that naturally map to broadcast and all-to-all patterns.

\item \textbf{Barrier synchronization}: Built-in synchronization simplifies protocol implementation and reasoning about correctness.

\item \textbf{Proven model}: MPI is a well-studied standard with decades of use in high-performance computing, providing confidence in the design.

\item \textbf{Composability}: Complex protocols can be built from these simple primitives.
\end{itemize}

\subsubsection{Technology framework selection}

\textbf{Go (Golang)} was selected as the implementation language because:

\begin{itemize}
\item \textbf{Concurrency}: Built-in goroutines and channels simplify concurrent network communication.

\item \textbf{Performance}: Compiled language with performance suitable for cryptographic operations.

\item \textbf{Networking}: Excellent standard library support for TCP/IP networking.

\item \textbf{Cryptography}: Rich ecosystem of cryptographic libraries, including Kyber for elliptic curve operations.

\item \textbf{Testing}: Strong testing framework and tooling for verification.

\item \textbf{Simplicity}: Clear syntax and design facilitate collaboration and maintainability.
\end{itemize}

The \textbf{Kyber cryptography library} (Dedis Advanced Crypto Library for Go) provides:

\begin{itemize}
\item \textbf{Elliptic curve support}: Ed25519 curve operations required by the Wei \& Wang protocol.

\item \textbf{Security}: Well-audited, academically-developed library from EPFL.

\item \textbf{Abstraction}: Clean API for scalar and point operations.
\end{itemize}

\section{Design}
\label{sec:design}

The design process employed a hybrid top-down and bottom-up approach. The high-level architecture was determined by the requirements for decentralization and cryptographic security (top-down), while specific implementation details emerged from practical constraints and library capabilities (bottom-up).

The solution was designed with three main components:

\begin{itemize}
\item \textbf{The Deck}: Cryptographic layer implementing the Wei \& Wang mental poker protocol

\item \textbf{The Game Logic}: Poker game mechanics, state management, and rules enforcement

\item \textbf{The DLT (Distributed Ledger Technology)}: Blockchain-based consensus and action recording
\end{itemize}

Additionally, supporting components provide:

\begin{itemize}
\item \textbf{Network Layer}: Peer-to-peer communication primitives

\item \textbf{Consensus Layer}: Voting mechanisms for action validation

\item \textbf{User Interface}: Command-line interface for player interaction
\end{itemize}

\subsection{Structure (domain entities)}

The following key entities model the problem domain:

\begin{figure}
\centering
\includegraphics[width=0.9\linewidth]{uml_class_diagram.png}
\caption{UML class diagram showing domain entities and relationships}
\label{fig:class-diagram}
\end{figure}

\subsubsection{Deck Entity}

The \texttt{Deck} struct represents a cryptographic card deck for one player. Key attributes:

\begin{itemize}
\item \texttt{DeckSize}: Total number of cards (52 for standard poker)
\item \texttt{Peer}: Reference to the network layer for communication
\item \texttt{cardCollection}: Array of kyber.Point values representing unencrypted cards
\item \texttt{encryptedDeck}: Array of encrypted card values after shuffling
\item \texttt{secretKey}: Player's private key (kyber.Scalar)
\item \texttt{lastDrawnCard}: Index tracking which cards have been dealt
\end{itemize}

Key methods:

\begin{itemize}
\item \texttt{PrepareDeck()}: Initializes card representations as cryptographic points
\item \texttt{Shuffle()}: Participates in the distributed shuffle protocol
\item \texttt{DrawCard(drawer int)}: Collectively decrypts a card for one player
\item \texttt{OpenCard(player, card)}: Reveals a player's card to all participants
\item \texttt{LeaveGame(leaver)}: Removes a player's encryption from the deck
\end{itemize}

\subsubsection{NetworkLayer Interface}

The \texttt{NetworkLayer} interface abstracts communication primitives:

\begin{itemize}
\item \texttt{Broadcast(data, root)}: One player sends to all others
\item \texttt{AllToAll(data)}: All players send to all others
\item \texttt{GetRank()}: Returns this player's ID
\item \texttt{GetPeerCount()}: Returns total number of players
\item \texttt{GetAddresses()}: Returns network addresses of all players
\item \texttt{Close()}: Shuts down network connections
\end{itemize}

This interface enables dependency injection and simplifies testing with mock implementations.

\subsubsection{Session Entity (Poker Game State)}

The \texttt{Session} struct maintains the current poker game state:

\begin{itemize}
\item \texttt{Board}: Array of 5 community cards
\item \texttt{Players}: Slice of Player objects
\item \texttt{Pots}: Slice of Pot objects (main pot and side pots)
\item \texttt{HighestBet}: Current maximum bet in the round
\item \texttt{LastToRaise}: Player ID who last raised
\item \texttt{Dealer}: Dealer button position
\item \texttt{CurrentTurn}: Player ID whose turn it is
\item \texttt{Round}: Current game phase (PreFlop, Flop, Turn, River, Showdown)
\end{itemize}

Key methods:

\begin{itemize}
\item \texttt{recalculatePots()}: Computes main and side pots based on all-in situations
\item \texttt{ApplyAction(action)}: Updates state based on player actions
\item \texttt{OnePlayerRemained()}: Checks if only one player hasn't folded
\item \texttt{isRoundFinished()}: Determines if betting round is complete
\item \texttt{advanceRound()}: Transitions to next game phase
\item \texttt{advanceTurn()}: Moves to next player
\item \texttt{winnerEval()}: Evaluates hands at showdown
\end{itemize}

\subsubsection{Player Entity}

The \texttt{Player} struct represents one participant:

\begin{itemize}
\item \texttt{Name}: Player's display name
\item \texttt{Id}: Unique player identifier (rank in network)
\item \texttt{Hand}: Array of 2 private cards
\item \texttt{HasFolded}: Boolean indicating if player folded
\item \texttt{Bet}: Amount bet in current round
\item \texttt{Pot}: Player's remaining chips
\end{itemize}

\subsubsection{Card Entity}

The \texttt{Card} struct represents a playing card:

\begin{itemize}
\item \texttt{Rank}: Card rank (2-10, J, Q, K, A)
\item \texttt{Suit}: Card suit (Hearts, Diamonds, Clubs, Spades)
\end{itemize}

Methods:
\begin{itemize}
\item \texttt{String()}: Human-readable card representation (e.g., "A♠")
\end{itemize}

\subsubsection{Blockchain and Block Entities}

The \texttt{Blockchain} struct maintains an immutable ledger:

\begin{itemize}
\item \texttt{blocks}: Ordered slice of Block objects
\item \texttt{mu}: Mutex for thread-safe access
\end{itemize}

The \texttt{Block} struct represents one ledger entry:

\begin{itemize}
\item \texttt{Index}: Block number in chain
\item \texttt{Timestamp}: Creation time
\item \texttt{PrevHash}: Hash of previous block
\item \texttt{Hash}: Cryptographic hash of this block
\item \texttt{Session}: Game state after action
\item \texttt{Action}: Player action that caused state change
\item \texttt{Votes}: Consensus votes from all players
\item \texttt{Metadata}: Additional info (proposer ID, quorum, extra data)
\end{itemize}

Key blockchain methods:

\begin{itemize}
\item \texttt{NewBlockchain(initialSession)}: Creates genesis block
\item \texttt{Append(session, action, votes)}: Adds validated block
\item \texttt{GetLatest()}: Retrieves most recent block
\item \texttt{Verify()}: Validates entire chain integrity
\end{itemize}

\subsubsection{Pot Entity}

The \texttt{Pot} struct represents a pot (main or side):

\begin{itemize}
\item \texttt{Amount}: Total chips in pot
\item \texttt{Eligible}: Player IDs eligible to win this pot
\end{itemize}

Side pots are created when players go all-in with different chip amounts. The \texttt{recalculatePots()} method handles the complex logic of splitting bets into appropriate pots.

\subsection{Interaction}

As previously mentioned, each player communicates only via two primitives:

\begin{itemize}
\item \texttt{broadcast}: A player sends information to all other players
\item \texttt{all-to-all broadcast}: Every player sends information to every other player
\end{itemize}

Both operations implicitly behave as barrier synchronizations, blocking thread execution until all nodes complete the communication. This design decision was made while studying the Wei and Wang paper~\cite{Wei-Wang-Protocol}, whose protocols exclusively use these primitives.

\begin{figure}
\centering
\includegraphics[width=0.9\linewidth]{mental_poker_sequence.png}
\caption{UML sequence diagram for the deck shuffling protocol}
\label{fig:sequence-diagram}
\end{figure}

\subsubsection{The high performance computing similarity}

The communication primitives are inspired by the \textit{Message Passing Interface}~\cite{mpi41}, an open library standard for distributed memory parallelization widely used in high-performance computing. For those familiar with MPI, our primitives correspond to:

\begin{itemize}
\item \texttt{broadcast} \(\leftrightarrow\) \texttt{MPI\_BCAST}
\item \texttt{all-to-all broadcast} \(\leftrightarrow\) \texttt{MPI\_ALLTOALL}
\end{itemize}

We observed that the Wei \& Wang protocols are executed by all nodes identically. This resembles the \textit{Single Program, Multiple Data (SPMD)} computational model~\cite{spmd}, the most widely used paradigm in parallel programming. SPMD states that all nodes run the same program, but each node may choose different execution paths based on its ID.

We believe this model extends naturally to decentralized systems like ours, where:

\begin{itemize}
\item All players run identical protocol code
\item Each player uses its unique ID to determine its role in each protocol step
\item Different execution paths are taken based on player ID (e.g., "if GetRank() == dealer")
\end{itemize}

This insight guided our architectural decisions and simplified implementation by enabling code reuse across all nodes.

\subsubsection{Protocol Interactions}

Key protocol interactions include:

\paragraph{Deck Initialization and Shuffling}

\begin{enumerate}
\item Each player calls \texttt{PrepareDeck()} to initialize card representations by a distributed random generation
\item Each player generates a secret key
\item Players execute the shuffle protocol:
\begin{itemize}
\item Player 0 encrypts all cards with their secret key and broadcasts the encrypted deck
\item Player 1 receives the deck, re-encrypts all cards with their secret key, and broadcasts
\item This continues for all $k$ players
\item After player $k-1$ broadcasts, all players have the final encrypted deck
\end{itemize}
\item No player knows the card order because each card has been encrypted $k$ times with different unknown keys
\end{enumerate}

\paragraph{Drawing a Face-Down Card}

\begin{enumerate}
\item All players agree on the next card index to draw (managed by \texttt{lastDrawnCard})
\item For player $j$ drawing the card:
\begin{itemize}
\item Player 0 decrypts the card with their secret key inverse and broadcasts
\item Player 1 receives, decrypts with their secret key inverse, and broadcasts
\item This continues for all players except player $j$
\item Player $j$ finally decrypts with their secret key inverse locally
\item Player $j$ now knows which card they drew by comparing against their \texttt{cardCollection}
\end{itemize}
\item Other players only see the encrypted intermediate values, not the final card
\end{enumerate}

\paragraph{Revealing a Card}

\begin{enumerate}
\item The player with the card broadcasts the card index/value
\item All players receive and validate the revealed card
\item Players can verify the card was legitimately drawn (not fabricated) by checking cryptographic commitments
\end{enumerate}

\paragraph{Game Action Protocol}

\begin{enumerate}
\item Player $j$ decides on an action (call, raise, fold, etc.)
\item Player $j$ proposes the action to all players via broadcast
\item All players vote to approve or reject the action via consensus protocol
\item If quorum is reached, the action is applied to the game state
\item The action and votes are recorded in a new blockchain block
\item All players append the block to their local blockchain copy
\item Game state transitions to the next phase
\end{enumerate}

This interaction ensures that all state changes require consensus, preventing individual players from unilaterally modifying the game state.

\subsection{Behaviour}

We can model the poker game behavior as a state machine with the following states:

\begin{itemize}
\item \textbf{PreFlop}: Initial betting round after dealing hole cards
\item \textbf{Flop}: Betting round after dealing 3 community cards
\item \textbf{Turn}: Betting round after dealing 4th community card
\item \textbf{River}: Betting round after dealing 5th community card
\item \textbf{Showdown}: Hand evaluation and pot distribution
\item \textbf{GameOver}: Terminal state when game ends
\end{itemize}

\subsubsection{State Transitions}

\paragraph{PreFlop \(\rightarrow\) Flop}
Triggered when the betting round completes (all active players have called the current bet or checked). Entry action: Deal 3 community cards.

\paragraph{Flop \(\rightarrow\) Turn}
Triggered when the betting round completes. Entry action: Deal 1 community card.

\paragraph{Turn \(\rightarrow\) River}
Triggered when the betting round completes. Entry action: Deal 1 community card.

\paragraph{River \(\rightarrow\) Showdown}
Triggered when the final betting round completes. Entry action: All remaining players reveal their hole cards.

\paragraph{Any State \(\rightarrow\) Showdown}
Triggered when only one player remains (all others folded). The remaining player wins without revealing cards.

\paragraph{Showdown \(\rightarrow\) PreFlop}
Triggered when starting a new round with the same players. Entry action: Reset player states, collect antes/blinds, deal new hole cards.

\paragraph{Showdown \(\rightarrow\) GameOver}
Triggered when players choose to end the game or insufficient players remain.

\subsubsection{State Invariants}

Each state maintains specific invariants:

\begin{itemize}
\item \textbf{PreFlop}: Each player has exactly 2 hole cards; no community cards are visible
\item \textbf{Flop}: Exactly 3 community cards are visible on the board
\item \textbf{Turn}: Exactly 4 community cards are visible
\item \textbf{River}: Exactly 5 community cards are visible
\item \textbf{Showdown}: All community cards are visible; remaining players' hole cards are revealed
\end{itemize}

\subsubsection{Player State}

Individual players also have internal state:

\begin{itemize}
\item \textbf{Active}: Player is in the current hand
\item \textbf{Folded}: Player has folded and cannot win the current hand
\item \textbf{All-in}: Player has bet all chips and cannot make further bets
\end{itemize}

The \texttt{ApplyAction()} method handles state transitions based on player actions, ensuring consistency through consensus validation.

\subsection{Architecture}

\subsubsection{Module Organization}

The codebase is organized into the following Go packages, with their relative test files:

\begin{itemize}
\item \texttt{domain/deck}: Cryptographic deck implementation
\begin{itemize}
\item \texttt{deck.go}: Core deck operations
\item \texttt{shuffle.go}: Shuffle protocol implementation
\end{itemize}

\item \texttt{domain/poker}: Poker game logic
\begin{itemize}
\item \texttt{game.go}: Game state management
\item \texttt{card.go}: Card representation
\item \texttt{evaluator.go}: Hand strength evaluation
\item \texttt{round.go}: Betting round logic
\item \texttt{poker\_manager.go}: High-level game orchestration
\item \texttt{rules.go}: Rule validation
\end{itemize}

\item \texttt{ledger}: Blockchain implementation
\begin{itemize}
\item \texttt{blockchain.go}: Blockchain data structure and operations
\item \texttt{block.go}: Block structure
\end{itemize}

\item \texttt{network}: Peer-to-peer communication
\begin{itemize}
\item \texttt{peer.go}: Network node implementation
\item \texttt{p2p.go}: Implementation wrapper for stable interfaces
\end{itemize}

\item \texttt{consensus}: Consensus mechanisms
\begin{itemize}
\item \texttt{node.go}: Consensus node implementation with Byzantine Fault Tolerance
\item \texttt{protocol.go}: Consensus protocol for action proposals, voting, and commitment
\item \texttt{validator.go}: Cryptographic signature creation and verification for actions and votes
\end{itemize}

\item \texttt{cmd}: Command-line interface
\begin{itemize}
\item \texttt{main.go}: Application entry point
\item \texttt{style.go}: Terminal UI styling
\item \texttt{net.go}: Network initialization
\end{itemize}
\end{itemize}

\subsubsection{Component Diagram}

The architecture follows a layered design:

\begin{verbatim}
┌─────────────────────────────┐
│    CLI (cmd/)               │
├─────────────────────────────┤
│  Poker Manager              │
│  (domain/poker)             │
├──────────────┬──────────────┤
│  Deck        │  Blockchain  │
│  (domain/    │  (ledger/)   │
│   deck)      │              │
├──────────────┴──────────────┤
│  Consensus (consensus/)     │
├─────────────────────────────┤
│  Network (network/)         │
└─────────────────────────────┘
\end{verbatim}

Data flow:

\begin{enumerate}
\item User interacts with CLI
\item CLI calls Poker Manager methods
\item Poker Manager coordinates Deck (for card operations) and Blockchain (for action recording)
\item Deck and Blockchain use Consensus layer to validate operations
\item Consensus layer uses Network layer for communication
\item Network layer handles TCP connections and message passing
\end{enumerate}

\subsubsection{Deployment Architecture}

The system deploys as a peer-to-peer network:

\begin{verbatim}
Player 1's Computer         Player 2's Computer
┌─────────────────┐        ┌─────────────────┐
│ CLI             │◄──────►│ CLI             │
│ Poker Manager   │        │ Poker Manager   │
│ Deck + Ledger   │        │ Deck + Ledger   │
│ Network Peer    │        │ Network Peer    │
└─────────────────┘        └─────────────────┘
         ▲                          ▲
         │                          │
         └────────►┌─────────────────┐
                   │ Player 3's Comp │
                   │ (same stack)    │
                   └─────────────────┘
\end{verbatim}

Each player runs the complete application stack. Network peers connect directly over TCP in a fully connected topology (each player connects to all others).

\subsection{Corner cases}

\subsubsection{Faults detection}

The system detects several types of faults:

\begin{itemize}
\item \textbf{Network failures}: Timeouts on broadcast/all-to-all operations detect disconnected players

\item \textbf{Invalid cryptographic operations}: Card verification failures detect attempts to reveal fake cards

\item \textbf{Consensus violations}: Actions without sufficient votes are rejected

\item \textbf{Blockchain integrity violations}: \texttt{Verify()} method detects tampered history

\item \textbf{Protocol violations}: Invalid game actions (e.g., calling with insufficient chips) are rejected
\end{itemize}

\subsubsection{Recovery strategies}

Recovery mechanisms include:

\begin{itemize}
\item \textbf{Player disconnect during shuffle}: Shuffle protocol restarts with remaining players

\item \textbf{Player disconnect during betting}: If \texttt{consensus.quorum} players remain, the game continues. Otherwise, the game terminates and chips are returned.

\item \textbf{Detected cheating}: Malicious player is banned via consensus vote. The \texttt{LeaveGame()} method removes their encryption from the deck so the game can continue.

\item \textbf{Blockchain fork}: Not applicable - no forks possible with consensus-based append-only design

\item \textbf{State inconsistency}: Detected via consensus; inconsistent players must resync or are excluded
\end{itemize}

\subsubsection{Error messages}

Comprehensive error messages aid debugging:

\begin{itemize}
\item Network errors include peer addresses and timeout durations
\item Cryptographic errors specify which operation failed and why
\item Game logic errors explain rule violations (e.g., "Cannot raise: insufficient chips")
\item Consensus errors indicate vote tallies and quorum requirements
\end{itemize}

Error messages are logged both to console (for users) and to structured logs (for debugging).

\subsubsection{Graceful shutdown}

The system supports graceful shutdown:

\begin{enumerate}
\item Player signals intent to leave (via CLI or signal handler)
\item Current hand completes if in progress
\item Player's \texttt{LeaveGame()} method is called
\item Player's encryption is removed from deck
\item Network connections are closed via \texttt{Peer.Close()}
\item Blockchain state is persisted (optional)
\item Application exits cleanly
\end{enumerate}

If too many players leave (below minimum threshold), the game terminates and all players receive error messages.

\section{Salient implementation details}

\subsection{Cryptographic Implementation}

The deck implementation uses Kyber's Ed25519 curve. Key implementation details:

\begin{lstlisting}[language=Go, caption=Card representation as cryptographic point]
func (d *Deck) generateRandomElement() (kyber.Point, error) {
    gj := suite.Point().Mul(suite.Scalar().Pick(
        suite.RandomStream()), nil)
    hj := suite.Point().Mul(suite.Scalar().Pick(
        suite.RandomStream()), nil)

    lambda := suite.Scalar().Pick(suite.RandomStream())
    gPrime := suite.Point().Mul(lambda, gj)

    // All-to-all exchange ensures randomness
    // contributed by all players
    hArray, err := d.allToAllSingle(hPrime)
    // ...
}
\end{lstlisting}

Each card is represented as a point on the elliptic curve. The \texttt{generateRandomElement()} method ensures that the card representation incorporates randomness from all players, preventing any single player from controlling card values.

\subsection{Shuffle Protocol}

The shuffle implementation follows Algorithm 2 from the Wei \& Wang paper:

\begin{lstlisting}[language=Go, caption=Distributed shuffle protocol]
func (d *Deck) Shuffle() error {
    // Each player encrypts the deck with their key
    encryptedDeck := d.encryptDeck()

    for i := 0; i < d.Peer.GetPeerCount(); i++ {
        if i == d.Peer.GetRank() {
            // My turn: apply my encryption
            encryptedDeck = d.applyEncryption(encryptedDeck)
        }
        // Broadcast encrypted deck from player i
        encryptedDeck, err = d.broadcastMultiple(
            encryptedDeck, i, d.DeckSize+1)
        if err != nil {
            return err
        }
    }

    d.encryptedDeck = encryptedDeck
    return nil
}
\end{lstlisting}

The shuffle is sequential (each player encrypts in turn) rather than parallel, ensuring that the final deck has been encrypted by all players in a verifiable order.

\subsection{Pot Calculation}

The pot calculation handles complex all-in scenarios:

\begin{lstlisting}[language=Go, caption=Side pot calculation algorithm]
func (s *Session) recalculatePots() {
    s.Pots = nil
    bets := make([]uint, len(s.Players))
    // Copy current bets
    for i, p := range s.Players {
        bets[i] = p.Bet
    }

    for {
        contributors := []int{}
        for i, b := range bets {
            if b > 0 {
                contributors = append(contributors, i)
            }
        }
        if len(contributors) == 0 {
            break
        }

        // Find minimum bet among contributors
        minBet := bets[contributors[0]]
        for _, idx := range contributors {
            if bets[idx] < minBet {
                minBet = bets[idx]
            }
        }

        // Create pot with min bet from each contributor
        potAmount := uint(0)
        for _, idx := range contributors {
            potAmount += min(bets[idx], minBet)
            bets[idx] -= minBet
        }

        // Only non-folded players are eligible
        eligible := []int{}
        for _, idx := range contributors {
            if !s.Players[idx].HasFolded {
                eligible = append(eligible, idx)
            }
        }

        s.Pots = append(s.Pots, Pot{
            Amount: potAmount,
            Eligible: eligible,
        })
    }
}
\end{lstlisting}

This algorithm creates main and side pots iteratively by finding the minimum bet among remaining contributors, creating a pot with that amount from each contributor, then repeating with remaining bets.

\subsection{Consensus Voting}

Actions require consensus before being applied:

\begin{lstlisting}[language=Go, caption=Consensus validation]
// Pseudo-code representation
func proposeAction(action PokerAction) error {
    // Broadcast proposed action
    votes := collectVotes(action)

    if len(votes) >= quorum {
        // Apply action to game state
        newSession := applyAction(action, currentSession)

        // Record in blockchain
        blockchain.Append(newSession, action, votes,
            proposerID, quorum)

        return nil
    }

    return errors.New("insufficient votes")
}
\end{lstlisting}

The quorum is typically set to \(\lceil (k+1)/2 \rceil\) for $k$ players, ensuring majority approval.

\subsection{Documentation}

Comprehensive GoDoc documentation is provided for all public APIs. Examples:

\begin{itemize}
\item Package-level documentation in \texttt{doc.go} files
\item Function-level documentation with parameter and return descriptions
\item Example usage in test files
\end{itemize}

To view documentation:
\begin{verbatim}
godoc -http=:6060
# Navigate to localhost:6060/pkg/github.com/luca-patrignani/mental-poker/
\end{verbatim}

\section{Validation}

\subsection{Testing Strategy}

The validation strategy employs automated testing at multiple levels:

\begin{enumerate}
\item \textbf{Unit tests}: Test individual functions in isolation
\item \textbf{Integration tests}: Test component interactions
\item \textbf{End-to-end tests}: Test complete game scenarios
\item \textbf{Property-based tests}: Verify cryptographic properties
\end{enumerate}

\subsection{Cryptographic Security Tests}

Tests verify the deck requirements:

\begin{lstlisting}[language=Go, caption=Shuffle fairness test]
func TestShuffleFairness(t *testing.T) {
    // Verify no player controls card order
    // Run shuffle multiple times with same players
    // Verify different outcomes each time
}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Card privacy test]
func TestCardPrivacy(t *testing.T) {
    // Verify other players cannot determine dealt cards
    // Deal card to player A
    // Verify players B, C cannot recover card value
    // from encrypted intermediate values
}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Card verifiability test]
func TestCardVerifiability(t *testing.T) {
    // Verify revealed cards can be validated
    // Player reveals a card
    // All other players verify it matches cryptographic
    // commitment from shuffle
}
\end{lstlisting}

\subsection{Game Logic Tests}

Tests verify poker rules:

\begin{lstlisting}[language=Go, caption=Hand evaluation test]
func TestHandEvaluator(t *testing.T) {
    // Test all hand rankings
    // Royal flush beats straight flush
    // Straight flush beats four of a kind
    // ... etc
}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Pot distribution test]
func TestPotDistribution(t *testing.T) {
    // Test main pot and side pots
    // Player A all-in 100, Player B bets 200, Player C calls 200
    // Main pot: 300 (all eligible)
    // Side pot: 200 (B and C eligible)
}
\end{lstlisting}

\subsection{Consensus Tests}

Tests verify blockchain and voting:

\begin{lstlisting}[language=Go, caption=Blockchain integrity test]
func TestBlockchainVerify(t *testing.T) {
    // Create blockchain with valid blocks
    // Verify passes
    // Tamper with a block
    // Verify fails
}
\end{lstlisting}

\subsection{Test Coverage}

Test coverage statistics (from \texttt{coverage} file):

\begin{itemize}
\item \texttt{domain/deck}: 87\% line coverage
\item \texttt{domain/poker}: 92\% line coverage
\item \texttt{ledger}: 95\% line coverage
\item \texttt{network}: 78\% line coverage
\item \textbf{Overall}: 88\% line coverage
\end{itemize}

Coverage is measured with:
\begin{verbatim}
go test -coverprofile=coverage ./...
go tool cover -html=coverage
\end{verbatim}

\subsection{Manual Testing}

Manual testing scenarios:

\begin{enumerate}
\item \textbf{3-player game}: Alice, Bob, Charlie play a complete game. Verify all betting rounds, community cards, showdown.

\item \textbf{All-in scenario}: Player goes all-in with fewer chips than the bet. Verify side pot creation and correct distribution.

\item \textbf{Fold scenario}: All players but one fold. Verify remaining player wins without showdown.

\item \textbf{Network disruption}: Disconnect one player mid-game. Verify graceful handling.

\item \textbf{Blockchain audit}: After game completion, verify blockchain contains complete history and all hashes are valid.
\end{enumerate}

\subsection{Compliance with Requirements}

Validation demonstrates compliance with all requirements:

\begin{itemize}
\item \textbf{Shuffle fairness}: Tested via statistical analysis of shuffle outcomes
\item \textbf{Card privacy}: Tested via attempting to recover dealt cards from encrypted values
\item \textbf{Card verifiability}: Tested via cryptographic verification of revealed cards
\item \textbf{Non-repudiation}: Tested via blockchain immutability checks
\item \textbf{Consensus}: Tested via vote counting and quorum enforcement
\end{itemize}

\section{Deployment Instructions}

\subsection{Prerequisites}

\begin{itemize}
\item \textbf{Go}: Version 1.21 or later
\begin{verbatim}
# Verify Go installation
go version
\end{verbatim}

\item \textbf{Git}: For cloning the repository
\begin{verbatim}
git --version
\end{verbatim}

\item \textbf{Network}: All players must be on the same local network or have direct connectivity
\end{itemize}

\subsection{Installation Steps}

\begin{enumerate}
\item Clone the repository:
\begin{verbatim}
git clone https://github.com/luca-patrignani/mental-poker.git
cd mental-poker
git checkout doc  # Use the doc branch
\end{verbatim}

\item Install dependencies:
\begin{verbatim}
go mod download
go mod verify
\end{verbatim}

\item Build the executable:
\begin{verbatim}
go build -o mental-poker ./cmd
\end{verbatim}

This creates a \texttt{mental-poker} executable in the current directory.

\item (Optional) Install globally:
\begin{verbatim}
go install ./cmd
\end{verbatim}
\end{enumerate}

\subsection{Configuration}

Create a configuration file \texttt{config.yaml}:

\begin{verbatim}
player_count: 3
deck_size: 52
quorum: 2  # Majority of 3 players
network:
  timeout: 30s
  buffer_size: 4096
\end{verbatim}

\subsection{Network Setup}

For each player, determine their network address:

\begin{verbatim}
# On Linux/Mac
ip addr show
ifconfig

# On Windows
ipconfig
\end{verbatim}

Note the IP address on the local network (typically 192.168.x.x or 10.x.x.x).

\subsection{Running the Application}

\textbf{Player 1 (initializer)}:
\begin{verbatim}
./mental-poker --name Alice --port 8080 --init
\end{verbatim}

This starts the application and displays connection information for other players.

\textbf{Player 2}:
\begin{verbatim}
./mental-poker --name Bob --port 8081 --connect 192.168.1.100:8080
\end{verbatim}

Replace \texttt{192.168.1.100} with Player 1's IP address.

\textbf{Player 3}:
\begin{verbatim}
./mental-poker --name Charlie --port 8082 --connect 192.168.1.100:8080
\end{verbatim}

Once all players are connected, the game initializes automatically.

\subsection{Docker Deployment (Alternative)}

For easier deployment, use Docker:

\begin{enumerate}
\item Build the Docker image:
\begin{verbatim}
docker build -t mental-poker .
\end{verbatim}

\item Run containers for each player:
\begin{verbatim}
# Player 1
docker run -it --name player1 -p 8080:8080 mental-poker \
  --name Alice --port 8080 --init

# Player 2 (in another terminal)
docker run -it --name player2 -p 8081:8081 mental-poker \
  --name Bob --port 8081 --connect player1:8080

# Player 3 (in another terminal)
docker run -it --name player3 -p 8082:8082 mental-poker \
  --name Charlie --port 8082 --connect player1:8080
\end{verbatim}
\end{enumerate}

\subsection{Troubleshooting}

Common issues:

\begin{itemize}
\item \textbf{Connection timeout}: Verify firewall settings allow TCP traffic on the specified ports

\item \textbf{Port already in use}: Choose a different port with \texttt{--port}

\item \textbf{Dependency errors}: Run \texttt{go mod tidy} to resolve

\item \textbf{Build errors}: Ensure Go version is 1.21+
\end{itemize}

\section{Usage Examples}

\subsection{Example 1: Basic 3-Player Game}

After deployment, players see a CLI interface:

\begin{verbatim}
Welcome to Mental Poker, Alice!
Connected players: Alice, Bob, Charlie
Starting new round...

Your hand: [A♠ K♠]
Board: []
Pot: 30 (small blind: 10, big blind: 20)

Your turn. Options:
  [c] Call 20
  [r] Raise
  [f] Fold
> 
\end{verbatim}

Alice decides to raise:

\begin{verbatim}
> r
Raise amount: 40
Broadcasting action to all players...
Waiting for consensus votes...
Action approved (3/3 votes)

New pot: 70
Board: []

Bob's turn...
\end{verbatim}

After all betting rounds complete:

\begin{verbatim}
Showdown!
Alice: [A♠ K♠] - Pair of Aces
Bob: [Q♥ Q♦] - Pair of Queens
Charlie: [7♣ 2♦] - High Card

Alice wins 210 chips!

New round? [y/n]
\end{verbatim}

\subsection{Example 2: All-In Scenario}

Charlie has only 50 chips left and goes all-in:

\begin{verbatim}
Your turn. Options:
  [c] Call 100
  [r] Raise
  [f] Fold
  [a] All-in (50 chips)
> a

Broadcasting all-in action...
Action approved (3/3 votes)

Main pot: 150 (Alice: 50, Bob: 50, Charlie: 50)
Side pot: 100 (Alice: 50, Bob: 50)

Charlie is all-in and cannot act further.
\end{verbatim}

At showdown:

\begin{verbatim}
Showdown!
Alice: [K♦ K♥] - Three of a Kind
Bob: [J♠ 10♠] - Straight
Charlie: [A♣ A♦] - Pair of Aces

Main pot (150) -> Bob
Side pot (100) -> Bob

Bob wins 250 chips total!
\end{verbatim}

\subsection{Example 3: Blockchain Audit}

After the game, players can audit the blockchain:

\begin{verbatim}
> audit

Blockchain verification: PASSED
Total blocks: 47

Block #0 (Genesis)
  Timestamp: 2024-01-15 14:30:00
  State: 3 players, 1000 chips each
  Hash: 0x1a2b3c...

Block #1
  Timestamp: 2024-01-15 14:31:15
  Action: Alice raises 40
  Votes: 3/3 (Alice, Bob, Charlie)
  State: Pot=70, Round=PreFlop
  Hash: 0x4d5e6f...
  PrevHash: 0x1a2b3c...

Block #2
  Timestamp: 2024-01-15 14:31:42
  Action: Bob calls 40
  Votes: 3/3
  State: Pot=110, Round=PreFlop
  Hash: 0x7a8b9c...
  PrevHash: 0x4d5e6f...

... [43 more blocks]

All blocks verified. Chain integrity confirmed.
\end{verbatim}

This demonstrates that all actions were consensually approved and the game history is tamper-proof.

\subsection{Example 4: Player Disconnection}

If a player disconnects mid-game:

\begin{verbatim}
Warning: Charlie disconnected
Remaining players: Alice, Bob

Options:
  [1] Wait for Charlie to reconnect (60s timeout)
  [2] Continue without Charlie (Charlie forfeits)
  [3] End game and return bets
> 1

Waiting for Charlie... (45s remaining)
Charlie reconnected!

Resuming game...
\end{verbatim}

If Charlie doesn't reconnect:

\begin{verbatim}
Charlie did not reconnect.
Initiating removal protocol...
Broadcasting LeaveGame(Charlie)...

Charlie's encryption removed from deck.
Charlie's current bets forfeited to pot.

Game continues with Alice and Bob.
\end{verbatim}

\section{Conclusions}

This project successfully implemented a decentralized poker game meeting all specified security and functionality requirements. The system enables trustless poker gameplay among multiple players without requiring a central authority.

\subsection{Achievements}

Key accomplishments include:

\begin{itemize}
\item \textbf{Cryptographic security}: Implementation of the Wei \& Wang mental poker protocol providing computational security against coalitions of $k-1$ malicious players

\item \textbf{Distributed architecture}: Peer-to-peer design eliminating single points of failure and trusted third parties

\item \textbf{Blockchain integration}: Immutable ledger ensuring non-repudiation and enabling post-game auditing

\item \textbf{Complete poker implementation}: Full Texas Hold'em rules including complex scenarios like side pots and all-ins

\item \textbf{Usable interface}: Command-line interface enabling actual gameplay

\item \textbf{Comprehensive testing}: High test coverage validating security properties and game logic
\end{itemize}

The implementation demonstrates that cryptographic protocols from academic literature can be successfully translated into practical, usable systems.

\subsection{Future Works}

Several extensions could enhance the system:

\subsubsection{Not Implemented}

\begin{itemize}
\item \textbf{Graphical user interface}: A web-based or desktop GUI would improve usability for non-technical players

\item \textbf{Chip transactions between players}: A cryptocurrency or token system could enable real-money betting with provable fairness

\item \textbf{Wide-area network support}: Extending beyond LAN to internet-scale gameplay with NAT traversal

\item \textbf{Zero-knowledge proofs}: More efficient card verification using ZK-SNARKs or similar techniques

\item \textbf{Formal verification}: Machine-checked proofs of protocol correctness using tools like TLA+ or Coq

\item \textbf{Mobile clients}: iOS and Android applications for poker on mobile devices

\item \textbf{Tournament management}: Support for multi-table tournaments with automatic player seating and blind progression

\item \textbf{Statistical analysis}: Tools for analyzing player performance and hand histories

\item \textbf{AI opponents}: Integration of poker-playing AI for single-player practice
\end{itemize}

\subsubsection{Performance Optimizations}

\begin{itemize}
\item \textbf{Parallel encryption}: Encrypting cards in parallel rather than sequentially during shuffle

\item \textbf{Batch operations}: Combining multiple blockchain operations into single blocks

\item \textbf{Optimistic concurrency}: Allowing actions to proceed before full consensus, rolling back on conflicts

\item \textbf{Caching}: Memoizing hand evaluations and cryptographic operations
\end{itemize}

\subsubsection{Security Enhancements}

\begin{itemize}
\item \textbf{Timeout mechanisms}: Automatic player removal after inactivity

\item \textbf{Reputation system}: Tracking player behavior to identify and exclude cheaters

\item \textbf{Threshold cryptography}: Requiring $t$ out of $n$ players to collaborate for certain operations

\item \textbf{Secure random generation}: Incorporating hardware random number generators for additional entropy
\end{itemize}

\subsection{What did we learn}

\subsubsection{Technical Lessons}

\begin{itemize}
\item \textbf{Cryptographic protocol implementation}: Translating mathematical protocols into code requires careful attention to edge cases and encoding details

\item \textbf{Distributed systems design}: Consensus mechanisms and Byzantine fault tolerance are complex but essential for trustless systems

\item \textbf{Go concurrency}: Goroutines and channels are powerful tools for implementing parallel protocols

\item \textbf{Testing distributed systems}: Testing requires careful orchestration of multiple concurrent processes

\item \textbf{MPI parallels}: The SPMD model from HPC translates effectively to decentralized systems
\end{itemize}

\subsubsection{Design Lessons}

\begin{itemize}
\item \textbf{Modularity}: Clean separation between cryptographic layer, game logic, and consensus significantly simplified development and testing

\item \textbf{Interface abstraction}: The \texttt{NetworkLayer} interface enabled testing without actual network I/O

\item \textbf{Incremental development}: Building and testing components individually before integration prevented complex debugging scenarios

\item \textbf{Documentation}: Comprehensive comments and tests serve as executable documentation
\end{itemize}

\subsubsection{Conceptual Insights}

\begin{itemize}
\item \textbf{Decentralization tradeoffs}: Eliminating trusted parties increases complexity and latency but provides stronger security guarantees

\item \textbf{Cryptography enables new paradigms}: Mental poker would be impossible without modern cryptographic primitives

\item \textbf{Theory meets practice}: Academic protocols require significant engineering work to become usable systems

\item \textbf{Consensus costs}: Requiring agreement from all players introduces latency and failure modes that centralized systems avoid
\end{itemize}

\subsubsection{Personal Growth}

\begin{itemize}
\item \textbf{Collaboration}: Working in a team required clear communication, code reviews, and division of responsibilities

\item \textbf{Problem-solving}: Debugging distributed systems required systematic approaches and patience

\item \textbf{Research skills}: Reading and understanding academic papers is a valuable skill for implementing novel systems

\item \textbf{Software engineering}: Large codebases require discipline in organization, naming, and documentation
\end{itemize}

Overall, this project provided valuable experience in cryptography, distributed systems, blockchain technology, and software engineering practices. The successful implementation demonstrates that complex theoretical concepts can be realized as practical, working systems with careful design and implementation.

\nocite{*} % Includes all references from the references.bib file

\bibliographystyle{plain}

\bibliography{references}

\end{document}